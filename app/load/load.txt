

each folder contains a single demo composed of multiple files that don't use code elsewhere


>once
each file only runs once even if you require it lots of times

>reach
a uses b, b uses c, a can't get to c

>grow

load.js has the map
two kinds of files: named and on the map, app and just use the entire library
notice and stop if you try to overwrite something

function in load that has an exports

a can reach c, but for this example we're saying that's ok







notice and stop if you try to overwrite something
baloons that can be written in any file and in any order
commands to combine and separate
modes to import explicitly, or just use global



>1normal









3 kinds of things
-library module
-demo
-test

be able to make any of these in any file, everything works, duplicates are noticed right away, and you can run everything from load.js, rather than giving node the file the demo is in


do all this on the command line, and then figure out what it looks like when electron is involved











ok, at this point you could stop, or you could play around here with baloon(metadata, function, more metadata like exports)
you like the idea of allow duplicate names, easily find anything

the three kinds of baloons are
app, demo, main
library module
test

the tests work with you runner or nodeunit








name the files in the root like this



main-something1.js
main-something2.js

test-text.js
test-hide.js
test-path.js

load.js

core-text.js
core-hide.js
core-path.js

(and from unify.js)

electron-main.js
electron-page.js
electron.html
electron.css



and of course none of the names inside matter because it's all in baloons
you found 3 four letter words for these things, "main", "test", and "core", and you think you like them


load.js

main.sun.js
main.moon.js
main.star.js


core.mountain.js
core.plain.js
core.ocean.js

test.mountain.js
test.plain.js
test.ocean.js



note.other.js
node.more.js




here's what a baloon might look like



load({type:"main", name:"something", tags:["tag1", "tag2", "tag3"]}, function() {
	

your existing code goes in here
hopefully you can keep it not indented, just as though you were writing it as you did before



return {
	//down here somehow you've got an object that exports stuff for use and tests
	//use that new es6 thing where you can mention each thing once, and get both the name and the value in an object
}});




a baloon just keeps some code separate, protecting it from other baloons
and then in the return, you describe what can be exported what different ways

app - run this to run a program or a unit of usefullness within a program
test - run these to test your code
library - core functions made available for apps and other library code to use
helper - parts of the library that only test code should use, not app code, exported just for tests

ok, and then you can only export functions
and load() takes care of exporting them
and by default it dumps them all in global
unless you're doing it the default node way, when they're added to export properly

ok, first, jsut make up the normal example to refamiliarize yourself with how you're supposed to do it



app1.js
app2.js


library1.js
library2.js


test1.js
test2.js






















in the return, 


and then, you see, it needs to work with both your system, and the default node stuff
for instance, if you do
$ nodeunit test.mountain.js
that should work
so the tests in there need to get exported in teh same way that nodeunit expects

likewise, make it so that you can export your node libraries the normal node way


























