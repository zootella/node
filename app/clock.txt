


clock0 - node on the terminal
clock1 - html page, javascript keeps the time up to date
clock2 - html page, jquery updates the time
clock3 - html page, react updates the time

clock1e - electron app, javascript updates the time
clock2e - electron app, jquery updates teh time
clock3e - electron app, react updates the time

1 html
2 jquery and handlebars
  ember
3 react



html, css and js are separate files in every case

the browser ones have libraries as save as, the node ones use node_modules


the electron ones tap into the flow javascript in the root, format the time using your time formatter, for instance


here also it would be interesting to set your spin check on updating the page, see if some methods are much faster or slower




>all in all, here's what you're trying to make and make sure about with clock

make sure that the fancy stack you end up choosing isn't a lot slower than just jquery changing the page as fast as it can

make sure that you don't spend all of your time changing the page, write something that measures how long events take, versus how long the program isn't processing an event

don't update more frequently than request animation frame, but do update more frequently than the current 200ms pulse screen
eventually don't have the 200ms pulse screen at all
have individual parts of the core and gui update as soon as they have new information for the user

200ms works ok for showing a changing speed, but doesn't work for listing subpaths within in a folder, for that, the user will want to see text blur by faster then they can read







(notes from demos)

		//TODO make two separate html files so you can watch them side by side
		//also, have the count be the time, or high resolution time even, so timeout doesn't win because it's a bigger number


//updates by event: how fast does it look? how much processor does it take?


//updates by animation frame, how fast does it look? how much processor does it take?

//first, make one that alternates 2 seconds using event, 2 seconds using animation frame, always counting up, and see if it looks any different
//then, try to measure how busy the page is, how much time javascript is running versus how much time it's idle--maybe by using the high resolution timer










make a little thing at the top that shows the current ratio of working versus idle
test it by running the busy loop that takes a second, that should record a full additional second of busy each time it happens




update every 200ms
have 50, 100, 200, 400 clocks

imagine a system that works variably
watches the working/idle ratio
uses getAnimationFrame
updates between that and 1s, depending on how slow the computer is
always obeys soon() or whatever, when something finishes, the whole thing updates immediately

and use a span for each 50, so there's wrapping that has to be calculated, too







also, for clock2, which uses
jquery
handlebars
underscore
bluebird

see how fast you can change a number on the screen with bluebird, does bluebird implement nexttick, essentially?
you're really surprised that setImmediate is a node-only thing

also, you can just do the ones that don't freeze the page








node has
process.hrtime([time])
The process.hrtime() method returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array
billionth of second

the browser has
t = performance.now();
measured in milliseconds, accurate to one thousandth of a millisecond
billionth of second





