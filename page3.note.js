








// Register a new Vue component, and if it's <page-component>, take over the page
function template(tag, t) {

	// Parse tag like "<some-component>" into name like "some-component"
	t.name = tag.parse("<", ">").middle;
	if (!is(t.name)) toss("code");

	// If we got called with CSS, have jQuery append it to <head>
	if (t.css) $(t.css).appendTo("head");
	Vue.component(t.name, { props: t.properties, template: t.template });

	// We're calling our outermost component <page-component>, and all index.html has is <div id="page"></div>
	if (tag == "<page-component>") { // This is the outermost component
		t.v = new Vue({ // Take over the page div, and save the root Vue instance
			el: '#page',
			template: `<div><page-component :key="p.id" :p="p"></page-component></div>`,
			data: { p: t.make() }
		});
	}

	return t; // Called to make the <page-component>, returns the root Vue instance as t.v
}
expose.core({template});










/*
from the handlebars days

// Make a string of HTML from the given Mustache template like "<p>{{color}}</p>" and optional content like {color: "blue"}
// Remember to call say() on each part of content to turn it into text
function template(template, content) {
	if (!content) content = {};
	var compiledTemplate = required.handlebars.compile(template);
	return compiledTemplate(content);
}
expose.core({template});
*/







/*
>notes when you thought you were back to jquery and handlebars

so maybe you're back to jquery and handlebars
and also, maybe this isn't that bad or that hard

a little part of the page is made of these parts
-a template
-a unique id, generated by makeUnique, and kept
-custom data that fills the template (raw data and rendered text)
-new custom data that should fill the template (raw data and rendered text) (maybe the text renderer is in here as a method, too)

you don't have dom diffing, but maybe you do'n tneed it
all you have to do is compare the custom data with the new custom data
the program can change new custom data as frequently as it wants, and it can do this quickly
and then periodically, 

the program keeps a global list of all the divs that are on the page, and they of course have unique ids
it runs down this list, comparing the data, and updating the div if necessary

and for now, don't worry about advanced features like
-optimizing to just show divs that are both on the page and visible on the screen
-throttling the refresh rate up and down depending on how complex the page is or how long it takes
instead, just update every div on the page, visible or not, and do it 60fps
this might be all you need ever, even

upside is now you can throw in and change whatever arbitrary text html you want, and at any time, rather than having a heirarchy of structure like vue wants
one of the kinds of components will just be a container, a div with an id, which you can add items to the start or end of, or clear and setup again entirely
it's ok if the page blinks when sorting, for instance
you'll have to figure out input controls like text boxes and buttons, and they'll likely have global ids, but having everything with a globally unique id might be easier because then you don't have the heirarchy of scope thing that react and vue like so much
you'll have to figure out how to keep the scroll position of different tabs
you probably should never show 10k items, and instead have pagination and an instant filter style search box when that happens
this is kind of an interesting challenge to design now
*/















/*
2018may19
stress test spin with hundreds of clocks
figure out if vue is already using requestAnimationFrame
make little vue samples and components

$ npm run electron-load main vue-update
*/













/*
instead of this.thing, do page.thing

this is going really well
next, do this:
-combine them, have containers in containers, lists in containers, components in components
-play around with scope, have them keep their own records, affect them from afar
-make the counter, clock, and timer
-make hasher

is v-if showing and hiding, or building and destroying the dom? you want the one that just hides. what's the other one called?


instead of arrays, can you use


instead of matching up idn555 numbers with program-specific ids, you can also always do this
call makeUnique once to get the prefix
then have as many as you want idn555-yourUniqueId
this is a really good idea


figure out button and text area
available and ghosted
event on edit
get and set text
make a little sample that shows how to do those things





in vue, some of the ideas from your own design might make sense
what if you designed it so that everything is a Thing
and a Thing always has a unique id
and a template
and a div where a list of subthings can grow (or if this thing doesn't need subthings, then just leave it blank)
so there's only one kind of thing
and then here's where you start to wrap and simplify vue, i guess





https://vuejs.org/v2/guide/conditional.html#v-if-vs-v-show
so probably use v-show
but then make sure when the user closes a tab, all that stuff actually gets destroyed, that the dom doesn't just grow larger and larger

you'll probably keep the pure data of the app pretty separate from the ui
and as such, the data will have idn99s that link up to the gui
so then everything will be going through page.thing rather than this.whatever
see what the grand looker-upper might be like, then






would vue mind if you started putting on everything
:key
:if
:show

vue html attributes like
v-if
v-show
v-on:click
v-for
v-bind:key
v-bind:properties

your object for each vue thing like
v.render
v.show
v.click
v.change
v.key
v.properties

values like
vn1

you'll also want to do css on the buttons for the standard 90s stuff like ghost, hot, pressed, set


figure out how to get all the vues in one part, and all the code that drives them far away, actually










vue-update
vue-update-component
vue-hide
vue-hide-component
vue-grow
vue-contain







ok, before you make the single vue thing that can be and do everything
get to know the small number of common controls you'll need a little better
div
button, make it all out of whatever usual fancy css buttons are made from, click it, get it to ghost, hot, set
text area, single line and multiline, set, get, notice change
image, you guess



make your own function view(), and then you don't have to globalize Vue actually





so how would you ship the hasher to a friend?
do you use webpack to turn all your code and all the node_modules into a single huge file?
figure this out, it's the non-hacker build






you don't have to solve the 500 clocks slow down the page problem right now
you do need to make sure that showing quick status doesn't slow down a single clock, or a single hash






vue-everything is working great
copy that and break it
use css(), and html() three times for <page-component>, <container-component>, and <item-component>




actually, before you do that, just make an example that has containers 3 levels deep
each one has a counter, a button, and a list of contents
theoretically you can make that out of a single kind of thing, too
and then update that to use css() and html()




*/








/*
three ideas that might be this side of the horizon, now

a single component that becomes everything
by containing a list of 0+ sub-things
no

$ [text box]
where you can enter a page
like a main but electron only, and you can have more than one running at a time
and then go back and convert some mains into pages this way
yes, try this one

a hyper-shorthand like [ text ] [Button]
that becomes vue that becomes html
no




*/







/*
make dent(``) so that you can use that for outline, and so that html snippets in the chrome dev tools look nicer
make it strict, too, throwing code if you give it something weird
have it require commas, not spaces, etc
*/






/*
style for mac

	//this is css the olde-fashioned way, not changing, and cascading downwards from the top of the html page
	$(`
		<style type="text/css">
			div, p {
				margin: 8px 0 8px 0;
			}
			button {
				background-color: #ddd;
				border: 1px solid #aaa;
				font-size: 14px;
				cursor: pointer;
			}
			button:hover {
				border: 1px solid #888;
			}
			input[type = text] {
				font-size: 14px;
				width: 300px;
			}
			.box {
				border: 1px solid #ccc;
				padding: 8px;
				background: #eee;
				margin: 4px;
			}
		</style>
	`).appendTo("head");

*/






















expose.main("snip3", function(a, b, c) {
	log("hi from snip3");
	var Vue = required.vue;

	Vue.component('log-item', {
		props: ['p'],
		template: `
			<div>{{ p.message }}</div>
		`
	});

	Vue.component('stick-item', {
		props: ['p'],
		template: `
			<div>
				<p>this is a stick item, really there will only be one</p>
				<p>{{ p.message }}</p>
			</div>
		`
	});

	var page = new Vue({
		el: '#page',
		template: `
			<div>
				<input type="button" value="Refresh" onClick="window.location.reload()"/>
				<p>
					<button v-on:click="method1">Method 1</button>
					<button v-on:click="method2">Method 2</button>
					<button v-on:click="method3">Method 3</button>
				</p>
				<p>hello snip three, where we will make simple local log and stick</p>
				<log-item v-for="p in logItems" v-bind:key="p.id" v-bind:p="p"></log-item>
				<stick-item v-bind:p="stickItem"></stick-item>
			</div>
		`,
		data: {
			logItems: [],
			stickItem: {message: "starting stick message", id: idn()}
		},
		methods: {
			method1() {
				this.logItems.push(makeLogItem("log message one"));
			},
			method2() {

			},
			method3() {
			},
		}
	});

	function makeLogItem(message) {
		let o = {};
		o.id = idn();
		o.message = sayDateTemplate(now().time, "dddHH12:MMaSS.TTT") + "s " + message;
		return o;
	}



});

















/*
is 'var win' local in expose main electron-main good enough? probably also loadCopy that onto global to really pin it
no, attach it to a program object that load already put on global
yeah, the application object, time to start thinking about that

try index.html?serialized js object of parameters so you don't have to transfer global arguments over ipc

do real ipc with node core module and bluebird
rather than all the synchronous electron cheats

look at the ipc stuff you did a year ago
update that with bluebird
*/

/*
wait, does electron have child and modal windows now?
https://github.com/electron/electron/blob/master/docs/api/browser-window.md
try that out

const {BrowserWindow} = require('electron')
let top = new BrowserWindow()
let child = new BrowserWindow({parent: top})
child.show()
top.show()
*/










